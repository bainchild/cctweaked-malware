-- uses unbios by jackmacwindows
-- also uses bios.lua from craftos2-rom by jackmacwindows and cc:t developers
-- (the end of the script)

-- only downside of this method
-- is the disk functionality
-- and rom becomes not read only
-- files are bundled for fault tolerance

local bios_src = [[
if fs.exists("virt") and not fs.isDir("virt") then
    local s,err=fs.delete("virt")
    assert(err==nil,err)
end
if not fs.exists("virt") then
    local s,err=fs.makeDir("virt")
    assert(err==nil,err)
end
-- these settings don't matter (other than motd.enable,
-- because motd is loaded before startups)
-- but might as well write them anyway
local h = assert(fs.open(".settings","w"))
h.write("{['shell.allow_disk_startup']=false,['shell.allow_startup']=false,['motd.enable']=true}")
h.close()
fs.delete("/virt/rom")
fs.copy("/rom","/virt/rom")
local assert,load,type,select,rawequal = assert,load or loadstring,type,select,rawequal
local peripheral_find = peripheral.find
function peripheral.find(...)
    if select("#",...) > 0 and type((...))=="string" and rawequal((...),"TPM1.0") then
        return {}
    end
    return peripheral_find(...)
end
--[=[
-- this comment has disk mounting/unmounting support
-- will make disk space take hard drive space, and
-- will cause lag
-- not finished
local tonumber = tonumber
local queue = os.queueEvent
local slots = {}
local disk_hasdata = disk.hasData
local fs_list = fs.list
local fs_copy = fs.copy
local fs_combine = fs.combine
local fs_delete = fs.delete
local fs_exists = fs.exists
local coroutine_yield = coroutine.yield
local coroutine_running = coroutine.running
function coroutine.yield(...)
    if ({coroutine_running()})[2] then
        -- this is basically pullevent
        -- terrible for performance, great for simplicity & compactness!
        for i,label in next, slots do
            if disk_hasdata(i) then
                for _,v in next, fs_list(fs_combine("virt",label)) do
                    local dest = fs_combine(label,v)
                    if fs_exists(dest) then fs_delete(dest) end
                    fs_copy(fs_combine("virt",label,v),dest)
                end
            end
        end
        local r = {coroutine_yield(...)}
        if #r>0 then
            if rawequal(r[1],"disk") then
                local used = {}
                for _,v in next, slots do
                    used[v=="disk" and 1 or tonumber(v:sub(5))] = true
                end
                local min
                for i=1,6 do
                    if not used[i] then min=i;break end
                end
                slots[r[1] ] = "disk"..(min==1 and "" or min)
                fs_copy(slots[r[1] ],fs_combine("virt",slots[r[1] ]))
            elseif rawequal(r[1],"disk_eject") then
                fs_delete(fs_combine("virt",slots[r[1] ]))
                slots[r[2] ] = nil
            end
        end
        return unpack(r)
    end
    return coroutine_yield(...)
end
]=]
local chroot = assert(load((...),"=bios2"))()
chroot.set_base("virt")
chroot.install_hooks()
assert(load(({...})[2],"=bios3"))()
while true do coroutine_yield() end
--chroot.remove_hooks()
]]
local libchroot_src = [[
-- has some minor problems with copy/move
-- (and aesthetic/filename leak problems with completion)
---@diagnostic disable: undefined-global
local chiro = { base = "/" }
---@diagnostic disable-next-line: deprecated
local select, unpack, type, next = select, (unpack or table.unpack), type, next
local fs_combine = fs.combine
local function split(a,b,c)
	local m = {}
	for mat in (a..(c or b)):gmatch("(.-)"..b) do
		m[#m+1]=mat
	end
	return m
end
local hooked = {}
function chiro.set_base(str)
	chiro.base = str
end
function chiro.install_hooks()
	for _, v in
		next,
		{
			"complete",
			"find",
			"list",
			"getSize",
			"exists",
			"isDir",
			"isReadOnly",
			"makeDir",
			"move",
			"copy",
			"delete",
			"open",
			"getFreeSpace",
			"getCapacity",
			"attributes",
		}
	do
	    if fs[v] then
		hooked[#hooked + 1] = {
			cont = fs,
			key = v,
			value = fs[v],
		}
		end
	end
	hooked[#hooked + 1] = {
		cont=os,
		key="run",
		value=os.run
	}
	local function hook_simple(f,name)
		return function(...)
			if select("#", ...) > 0 and type((...)) == "string" then
				local arj = { ... }
				if fs_combine(arj[1]):gsub("[%*%?]", ""):sub(1, 2) == ".." then
					arj[1] = fs_combine(arj[1])
				else
					arj[1] = fs_combine(chiro.base, arj[1])
				end
				-- print(name,unpack(arj))
				return f(unpack(arj))
			end
			return f(...)
		end
	end
	for _, v in
		next,
		{
			-- "find",
			"list",
			"getSize",
			"exists",
			"isDir",
			"isReadOnly",
			"makeDir",
			"delete",
			"open",
			-- "getDrive",
			"getFreeSpace",
			"getCapacity",
			"attributes",
		}
	do
		fs[v] = hook_simple(fs[v],"fs."..v)
	end
	local fs_find = fs.find
	if fs_find then
	function fs.find(...)
		if select("#", ...) > 0 and type((...)) == "string" then
			local path = ...
			if fs_combine(path):gsub("[%*%?]","") == "" then -- fs.find(".") and all the variations
				return {}
			end
			if fs_combine(path):gsub("[%*%?]", ""):sub(1, 2) == ".." then
				path = fs_combine(path)
			else
				path = fs_combine(chiro.base, path)
			end
			return fs_find(path, unpack({ ... }, 3))
		end
	end
	end
	local os_run = os.run
	-- hooked[#hooked + 1] = { cont = os, key = "run", value = os_run }
	function os.run(...)
		if select("#", ...) > 0 and type((...)) == "string" then
			local env, path = ...
			if fs_combine(path):gsub("[%*%?]", ""):sub(1, 2) == ".." then
				path = fs_combine(path)
			else
				path = fs_combine(chiro.base, path)
			end
			return os_run(env, path, unpack({ ... }, 3))
		end
		return os_run(...)
	end
	local fs_move = fs.move
	-- hooked[#hooked + 1] = { cont = fs, key = "move", value = fs_move }
	function fs.move(...)
		if select("#", ...) > 1 and type((...)) == "string" and type(({ ... })[2]) == "string" then
			local src, dest = ...
			if fs_combine(src):gsub("[%*%?]", ""):sub(1, 2) == ".." then
				src = fs_combine(src)
			else
				src = fs_combine(chiro.base, src)
			end
			if fs_combine(dest):gsub("[%*%?]", ""):sub(1, 2) == ".." then
				dest = fs_combine(dest)
			else
				dest = fs_combine(chiro.base, dest)
			end
			-- print("compare",src,split((dest:gsub("[%*%?]","")).."/","/")[1])
			-- if src:sub(1,13)=="root2/root2/" then
			-- 	print(debug.traceback("AAAAAAAAAAA"))
			-- end
			if src==split((dest:gsub("[%*%?]","")).."/","/")[1] then
				error("Cannot move a directory inside itself!",2)
			end
			return fs_move(src, dest, unpack({ ... }, 3))
		end
		return fs_move(...)
	end
	local fs_copy = fs.copy
	-- hooked[#hooked + 1] = { cont = fs, key = "copy", value = fs_copy }
	function fs.copy(...)
		if select("#", ...) > 1 and type((...)) == "string" and type(({ ... })[2]) == "string" then
			local src, dest = ...
			if fs_combine(src):gsub("[%*%?]", ""):sub(1, 2) == ".." then
				src = fs_combine(src)
			else
				src = fs_combine(chiro.base, src)
			end
			if fs_combine(dest):gsub("[%*%?]", ""):sub(1, 2) == ".." then
				dest = fs_combine(dest)
			else
				dest = fs_combine(chiro.base, dest)
			end
			-- print("src,dest",src,dest)
			if src==split((dest:gsub("[%*%?]","")).."/","/")[1] then
				error("Cannot copy a directory inside itself!",2)
			end
			return fs_copy(src, dest, unpack({ ... }, 3))
		end
		return fs_copy(...)
	end
end
function chiro.remove_hooks()
	for _, v in next, hooked do
		v.cont[v.key] = v.value
	end
	hooked = {}
end
return chiro
]]
local ibios_src = [===[
-- SPDX-FileCopyrightText: 2017 Daniel Ratcliffe
--
-- SPDX-License-Identifier: LicenseRef-CCPL

-- Load in expect from the module path.
--
-- Ideally we'd use require, but that is part of the shell, and so is not
-- available to the BIOS or any APIs. All APIs load this using dofile, but that
-- has not been defined at this point.
local expect

do
    local h = fs.open("rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "@/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f().expect
end

-- Disable JIT on Apple Silicon.
-- (This is also in the C++ source, but for some reason it doesn't work.)
if jit and jit.os == "OSX" and jit.arch == "arm64" then jit.off() end

-- Historically load/loadstring would handle the chunk name as if it has
-- been prefixed with "=". We emulate that behaviour here.
local function prefix(chunkname)
    if type(chunkname) ~= "string" then return chunkname end
    local head = chunkname:sub(1, 1)
    if head == "=" or head == "@" then
        return chunkname
    else
        return "=" .. chunkname
    end
end

if _VERSION == "Lua 5.1" then
    -- If we're on Lua 5.1, install parts of the Lua 5.2/5.3 API so that programs can be written against it
    local type = type
    local nativeload = load
    local nativeloadstring = loadstring
    local nativesetfenv = setfenv

    function load(x, name, mode, env)
        expect(1, x, "function", "string")
        expect(2, name, "string", "nil")
        expect(3, mode, "string", "nil")
        expect(4, env, "table", "nil")

        local ok, p1, p2 = pcall(function()
            if type(x) == "string" then
                local result, err = nativeloadstring(x, name)
                if result then
                    if env then
                        env._ENV = env
                        nativesetfenv(result, env)
                    end
                    return result
                else
                    return nil, err
                end
            else
                local result, err = nativeload(x, name)
                if result then
                    if env then
                        env._ENV = env
                        nativesetfenv(result, env)
                    end
                    return result
                else
                    return nil, err
                end
            end
        end)
        if ok then
            return p1, p2
        else
            error(p1, 2)
        end
    end

    if _CC_DISABLE_LUA51_FEATURES then
        -- Remove the Lua 5.1 features that will be removed when we update to Lua 5.2, for compatibility testing.
        -- See "disable_lua51_functions" in ComputerCraft.cfg
        setfenv = nil
        getfenv = nil
        loadstring = nil
        unpack = nil
        math.log10 = nil
        table.maxn = nil
    else
        loadstring = function(string, chunkname) return nativeloadstring(string, prefix(chunkname)) end

        -- Inject a stub for the old bit library
        _G.bit = {
            bnot = bit32.bnot,
            band = bit32.band,
            bor = bit32.bor,
            bxor = bit32.bxor,
            brshift = bit32.arshift,
            blshift = bit32.lshift,
            blogic_rshift = bit32.rshift,
        }
    end
elseif not _CC_DISABLE_LUA51_FEATURES then
    -- Restore old Lua 5.1 functions for compatibility
    if not getfenv or not setfenv then
        -- setfenv/getfenv replacements from https://leafo.net/guides/setfenv-in-lua52-and-above.html
        function setfenv(fn, env)
            if not debug then error("could not set environment", 2) end
            if type(fn) == "number" then fn = debug.getinfo(fn + 1, "f").func end
            local i = 1
            while true do
                local name = debug.getupvalue(fn, i)
                if name == "_ENV" then
                    debug.upvaluejoin(fn, i, (function()
                        return env
                    end), 1)
                    break
                elseif not name then
                    break
                end

                i = i + 1
            end

            return fn
        end

        function getfenv(fn)
            if not debug then error("could not set environment", 2) end
            if type(fn) == "number" then fn = debug.getinfo(fn + 1, "f").func end
            local i = 1
            while true do
                local name, val = debug.getupvalue(fn, i)
                if name == "_ENV" then
                    return val
                elseif not name then
                    break
                end
                i = i + 1
            end
        end
    end

    function table.maxn(tab)
        local num = 0
        for k in pairs(tab) do
            if type(k) == "number" and k > num then
                num = k
            end
        end
        return num
    end

    math.log10 = function(x) return math.log(x, 10) end
    loadstring = function(string, chunkname) return load(string, prefix(chunkname)) end
    unpack = table.unpack

    -- Inject a stub for the old bit library
    _G.bit = {
        bnot = bit32.bnot,
        band = bit32.band,
        bor = bit32.bor,
        bxor = bit32.bxor,
        brshift = bit32.arshift,
        blshift = bit32.lshift,
        blogic_rshift = bit32.rshift,
    }
end

-- Install lua parts of the os api
function os.version()
    return "CraftOS 1.9"
end

function os.pullEventRaw(sFilter)
    return coroutine.yield(sFilter)
end

function os.pullEvent(sFilter)
    local eventData = table.pack(os.pullEventRaw(sFilter))
    if eventData[1] == "terminate" then
        error("Terminated", 0)
    end
    return table.unpack(eventData, 1, eventData.n)
end

-- Install globals
function sleep(nTime)
    expect(1, nTime, "number", "nil")
    local timer = os.startTimer(nTime or 0)
    repeat
        local _, param = os.pullEvent("timer")
    until param == timer
end

function write(sText)
    expect(1, sText, "string", "number")

    local w, h = term.getSize()
    local x, y = term.getCursorPos()

    local nLinesPrinted = 0
    local function newLine()
        if y + 1 <= h then
            term.setCursorPos(1, y + 1)
        else
            term.setCursorPos(1, h)
            term.scroll(1)
        end
        x, y = term.getCursorPos()
        nLinesPrinted = nLinesPrinted + 1
    end

    -- Print the line with proper word wrapping
    sText = tostring(sText)
    while #sText > 0 do
        local whitespace = string.match(sText, "^[ \t]+")
        if whitespace then
            -- Print whitespace
            term.write(whitespace)
            x, y = term.getCursorPos()
            sText = string.sub(sText, #whitespace + 1)
        end

        local newline = string.match(sText, "^\n")
        if newline then
            -- Print newlines
            newLine()
            sText = string.sub(sText, 2)
        end

        local text = string.match(sText, "^[^ \t\n]+")
        if text then
            sText = string.sub(sText, #text + 1)
            if #text > w then
                -- Print a multiline word
                while #text > 0 do
                    if x > w then
                        newLine()
                    end
                    term.write(text)
                    text = string.sub(text, w - x + 2)
                    x, y = term.getCursorPos()
                end
            else
                -- Print a word normally
                if x + #text - 1 > w then
                    newLine()
                end
                term.write(text)
                x, y = term.getCursorPos()
            end
        end
    end

    return nLinesPrinted
end

function print(...)
    local nLinesPrinted = 0
    local nLimit = select("#", ...)
    for n = 1, nLimit do
        local s = tostring(select(n, ...))
        if n < nLimit then
            s = s .. "\t"
        end
        nLinesPrinted = nLinesPrinted + write(s)
    end
    nLinesPrinted = nLinesPrinted + write("\n")
    return nLinesPrinted
end

function printError(...)
    local oldColour
    if term.isColour() then
        oldColour = term.getTextColour()
        term.setTextColour(colors.red)
    end
    print(...)
    if term.isColour() then
        term.setTextColour(oldColour)
    end
end

function read(_sReplaceChar, _tHistory, _fnComplete, _sDefault)
    expect(1, _sReplaceChar, "string", "nil")
    expect(2, _tHistory, "table", "nil")
    expect(3, _fnComplete, "function", "nil")
    expect(4, _sDefault, "string", "nil")

    term.setCursorBlink(true)

    local sLine
    if type(_sDefault) == "string" then
        sLine = _sDefault
    else
        sLine = ""
    end
    local nHistoryPos
    local nPos, nScroll = #sLine, 0
    if _sReplaceChar then
        _sReplaceChar = string.sub(_sReplaceChar, 1, 1)
    end

    local tCompletions
    local nCompletion
    local function recomplete()
        if _fnComplete and nPos == #sLine then
            tCompletions = _fnComplete(sLine)
            if tCompletions and #tCompletions > 0 then
                nCompletion = 1
            else
                nCompletion = nil
            end
        else
            tCompletions = nil
            nCompletion = nil
        end
    end

    local function uncomplete()
        tCompletions = nil
        nCompletion = nil
    end

    local w = term.getSize()
    local sx = term.getCursorPos()

    local function redraw(_bClear)
        local cursor_pos = nPos - nScroll
        if sx + cursor_pos >= w then
            -- We've moved beyond the RHS, ensure we're on the edge.
            nScroll = sx + nPos - w
        elseif cursor_pos < 0 then
            -- We've moved beyond the LHS, ensure we're on the edge.
            nScroll = nPos
        end

        local _, cy = term.getCursorPos()
        term.setCursorPos(sx, cy)
        local sReplace = _bClear and " " or _sReplaceChar
        if sReplace then
            term.write(string.rep(sReplace, math.max(#sLine - nScroll, 0)))
        else
            term.write(string.sub(sLine, nScroll + 1))
        end

        if nCompletion then
            local sCompletion = tCompletions[nCompletion]
            local oldText, oldBg
            if not _bClear then
                oldText = term.getTextColor()
                oldBg = term.getBackgroundColor()
                term.setTextColor(colors.white)
                term.setBackgroundColor(colors.gray)
            end
            if sReplace then
                term.write(string.rep(sReplace, #sCompletion))
            else
                term.write(sCompletion)
            end
            if not _bClear then
                term.setTextColor(oldText)
                term.setBackgroundColor(oldBg)
            end
        end

        term.setCursorPos(sx + nPos - nScroll, cy)
    end

    local function clear()
        redraw(true)
    end

    recomplete()
    redraw()

    local function acceptCompletion()
        if nCompletion then
            -- Clear
            clear()

            -- Find the common prefix of all the other suggestions which start with the same letter as the current one
            local sCompletion = tCompletions[nCompletion]
            sLine = sLine .. sCompletion
            nPos = #sLine

            -- Redraw
            recomplete()
            redraw()
        end
    end
    while true do
        local sEvent, param, param1, param2 = os.pullEvent()
        if sEvent == "char" then
            -- Typed key
            clear()
            sLine = string.sub(sLine, 1, nPos) .. param .. string.sub(sLine, nPos + 1)
            nPos = nPos + 1
            recomplete()
            redraw()

        elseif sEvent == "paste" then
            -- Pasted text
            clear()
            sLine = string.sub(sLine, 1, nPos) .. param .. string.sub(sLine, nPos + 1)
            nPos = nPos + #param
            recomplete()
            redraw()

        elseif sEvent == "key" then
            if param == keys.enter or param == keys.numPadEnter then
                -- Enter/Numpad Enter
                if nCompletion then
                    clear()
                    uncomplete()
                    redraw()
                end
                break

            elseif param == keys.left then
                -- Left
                if nPos > 0 then
                    clear()
                    nPos = nPos - 1
                    recomplete()
                    redraw()
                end

            elseif param == keys.right then
                -- Right
                if nPos < #sLine then
                    -- Move right
                    clear()
                    nPos = nPos + 1
                    recomplete()
                    redraw()
                else
                    -- Accept autocomplete
                    acceptCompletion()
                end

            elseif param == keys.up or param == keys.down then
                -- Up or down
                if nCompletion then
                    -- Cycle completions
                    clear()
                    if param == keys.up then
                        nCompletion = nCompletion - 1
                        if nCompletion < 1 then
                            nCompletion = #tCompletions
                        end
                    elseif param == keys.down then
                        nCompletion = nCompletion + 1
                        if nCompletion > #tCompletions then
                            nCompletion = 1
                        end
                    end
                    redraw()

                elseif _tHistory then
                    -- Cycle history
                    clear()
                    if param == keys.up then
                        -- Up
                        if nHistoryPos == nil then
                            if #_tHistory > 0 then
                                nHistoryPos = #_tHistory
                            end
                        elseif nHistoryPos > 1 then
                            nHistoryPos = nHistoryPos - 1
                        end
                    else
                        -- Down
                        if nHistoryPos == #_tHistory then
                            nHistoryPos = nil
                        elseif nHistoryPos ~= nil then
                            nHistoryPos = nHistoryPos + 1
                        end
                    end
                    if nHistoryPos then
                        sLine = _tHistory[nHistoryPos]
                        nPos, nScroll = #sLine, 0
                    else
                        sLine = ""
                        nPos, nScroll = 0, 0
                    end
                    uncomplete()
                    redraw()

                end

            elseif param == keys.backspace then
                -- Backspace
                if nPos > 0 then
                    clear()
                    sLine = string.sub(sLine, 1, nPos - 1) .. string.sub(sLine, nPos + 1)
                    nPos = nPos - 1
                    if nScroll > 0 then nScroll = nScroll - 1 end
                    recomplete()
                    redraw()
                end

            elseif param == keys.home then
                -- Home
                if nPos > 0 then
                    clear()
                    nPos = 0
                    recomplete()
                    redraw()
                end

            elseif param == keys.delete then
                -- Delete
                if nPos < #sLine then
                    clear()
                    sLine = string.sub(sLine, 1, nPos) .. string.sub(sLine, nPos + 2)
                    recomplete()
                    redraw()
                end

            elseif param == keys["end"] then
                -- End
                if nPos < #sLine then
                    clear()
                    nPos = #sLine
                    recomplete()
                    redraw()
                end

            elseif param == keys.tab then
                -- Tab (accept autocomplete)
                acceptCompletion()

            end

        elseif sEvent == "mouse_click" or sEvent == "mouse_drag" and param == 1 then
            local _, cy = term.getCursorPos()
            if param1 >= sx and param1 <= w and param2 == cy then
                -- Ensure we don't scroll beyond the current line
                nPos = math.min(math.max(nScroll + param1 - sx, 0), #sLine)
                redraw()
            end

        elseif sEvent == "term_resize" then
            -- Terminal resized
            w = term.getSize()
            redraw()

        end
    end

    local _, cy = term.getCursorPos()
    term.setCursorBlink(false)
    term.setCursorPos(w + 1, cy)
    print()

    return sLine
end

function loadfile(filename, mode, env)
    -- Support the previous `loadfile(filename, env)` form instead.
    if type(mode) == "table" and env == nil then
        mode, env = nil, mode
    end

    expect(1, filename, "string")
    expect(2, mode, "string", "nil")
    expect(3, env, "table", "nil")

    local file = fs.open(filename, "r")
    if not file then return nil, "File not found" end

    local func, err = load(file.readAll(), "@/" .. fs.combine(filename), mode, env)
    file.close()
    return func, err
end

function dofile(_sFile)
    expect(1, _sFile, "string")

    local fnFile, e = loadfile(_sFile, nil, _G)
    if fnFile then
        return fnFile()
    else
        error(e, 2)
    end
end

-- Install the rest of the OS api
function os.run(_tEnv, _sPath, ...)
    expect(1, _tEnv, "table")
    expect(2, _sPath, "string")

    local tEnv = _tEnv
    setmetatable(tEnv, { __index = _G })

    if settings.get("bios.strict_globals", false) then
        -- load will attempt to set _ENV on this environment, which
        -- throws an error with this protection enabled. Thus we set it here first.
        tEnv._ENV = tEnv
        getmetatable(tEnv).__newindex = function(_, name)
          error("Attempt to create global " .. tostring(name), 2)
        end
    end

    local fnFile, err = loadfile(_sPath, nil, tEnv)
    if fnFile then
        local ok, err = pcall(fnFile, ...)
        if not ok then
            if err and err ~= "" then
                printError(err)
            end
            return false
        end
        return true
    end
    if err and err ~= "" then
        printError(err)
    end
    return false
end

local tAPIsLoading = {}
function os.loadAPI(_sPath)
    expect(1, _sPath, "string")
    local sName = fs.getName(_sPath)
    if sName:sub(-4) == ".lua" then
        sName = sName:sub(1, -5)
    end
    if tAPIsLoading[sName] == true then
        printError("API " .. sName .. " is already being loaded")
        return false
    end
    tAPIsLoading[sName] = true

    local tEnv = {}
    setmetatable(tEnv, { __index = _G })
    local fnAPI, err = loadfile(_sPath, nil, tEnv)
    if fnAPI then
        local ok, err = pcall(fnAPI)
        if not ok then
            tAPIsLoading[sName] = nil
            return error("Failed to load API " .. sName .. " due to " .. err, 1)
        end
    else
        tAPIsLoading[sName] = nil
        return error("Failed to load API " .. sName .. " due to " .. err, 1)
    end

    local tAPI = {}
    for k, v in pairs(tEnv) do
        if k ~= "_ENV" then
            tAPI[k] =  v
        end
    end

    _G[sName] = tAPI
    tAPIsLoading[sName] = nil
    return true
end

function os.unloadAPI(_sName)
    expect(1, _sName, "string")
    if _sName ~= "_G" and type(_G[_sName]) == "table" then
        _G[_sName] = nil
    end
end

function os.sleep(nTime)
    sleep(nTime)
end

local nativeShutdown = os.shutdown
function os.shutdown(...)
    nativeShutdown(...)
    while true do
        coroutine.yield()
    end
end

local nativeReboot = os.reboot
function os.reboot()
    nativeReboot()
    while true do
        coroutine.yield()
    end
end

local bAPIError = false
local function load_apis(dir)
    if not fs.isDir(dir) then return end

    for _, file in ipairs(fs.list(dir)) do
        if file:sub(1, 1) ~= "." then
            local path = fs.combine(dir, file)
            if not fs.isDir(path) then
                if not os.loadAPI(path) then
                    bAPIError = true
                end
            end
        end
    end
end

-- Load APIs
load_apis("rom/apis")
if http then load_apis("rom/apis/http") end
if turtle then load_apis("rom/apis/turtle") end
if pocket then load_apis("rom/apis/pocket") end

if commands and fs.isDir("rom/apis/command") then
    -- Load command APIs
    if os.loadAPI("rom/apis/command/commands.lua") then
        -- Add a special case-insensitive metatable to the commands api
        local tCaseInsensitiveMetatable = {
            __index = function(table, key)
                local value = rawget(table, key)
                if value ~= nil then
                    return value
                end
                if type(key) == "string" then
                    local value = rawget(table, string.lower(key))
                    if value ~= nil then
                        return value
                    end
                end
                return nil
            end,
        }
        setmetatable(commands, tCaseInsensitiveMetatable)
        setmetatable(commands.async, tCaseInsensitiveMetatable)

        -- Add global "exec" function
        exec = commands.exec
    else
        bAPIError = true
    end
end

if bAPIError then
    print("Press any key to continue")
    os.pullEvent("key")
    term.clear()
    term.setCursorPos(1, 1)
end

-- Set default settings
settings.define("shell.allow_startup", {
    default = true,
    description = "Run startup files when the computer turns on.",
    type = "boolean",
})
settings.define("shell.allow_disk_startup", {
    default = commands == nil,
    description = "Run startup files from disk drives when the computer turns on.",
    type = "boolean",
})

settings.define("shell.autocomplete", {
    default = true,
    description = "Autocomplete program and arguments in the shell.",
    type = "boolean",
})
settings.define("edit.autocomplete", {
    default = true,
    description = "Autocomplete API and function names in the editor.",
        type = "boolean",
})
settings.define("lua.autocomplete", {
    default = true,
    description = "Autocomplete API and function names in the Lua REPL.",
        type = "boolean",
})

settings.define("edit.default_extension", {
    default = "lua",
    description = [[The file extension the editor will use if none is given. Set to "" to disable.]],
    type = "string",
})
settings.define("paint.default_extension", {
    default = "nfp",
    description = [[The file extension the paint program will use if none is given. Set to "" to disable.]],
    type = "string",
})

settings.define("list.show_hidden", {
    default = false,
    description = [[Show hidden files (those starting with "." in the Lua REPL).]],
    type = "boolean",
})

settings.define("motd.enable", {
    default = pocket == nil,
    description = "Display a random message when the computer starts up.",
    type = "boolean",
})
settings.define("motd.path", {
    default = mobile and "/rom/motd.txt:/rom/programs/mobile/motd.txt:/motd.txt" or "/rom/motd.txt:/motd.txt",
    description = [[The path to load random messages from. Should be a colon (":") separated string of file paths.]],
    type = "string",
})

settings.define("lua.warn_against_use_of_local", {
    default = true,
    description = [[Print a message when input in the Lua REPL starts with the word 'local'. Local variables defined in the Lua REPL are be inaccessable on the next input.]],
    type = "boolean",
})
settings.define("lua.function_args", {
    default = true,
    description = "Show function arguments when printing functions.",
    type = "boolean",
})
settings.define("lua.function_source", {
    default = false,
    description = "Show where a function was defined when printing functions.",
    type = "boolean",
})
settings.define("bios.strict_globals", {
    default = false,
    description = "Prevents assigning variables into a program's environment. Make sure you use the local keyword or assign to _G explicitly.",
    type = "boolean",
})
settings.define("shell.autocomplete_hidden", {
    default = false,
    description = [[Autocomplete hidden files and folders (those starting with ".").]],
    type = "boolean",
})
settings.define("shell.package_path", {
    default = "?;?.lua;?/init.lua;/rom/modules/main/?;/rom/modules/main/?.lua;/rom/modules/main/?/init.lua",
    description = [[Controls where program libraries can be stored. Paths are separated by semicolons (";"), and are relative to the original program. The 'require' function will search for a file at each path in order, replacing question marks ("?") with the library name.]],
    type = "string",
})

settings.define("shell.report_plugin_errors", {
    default = true,
    description = "Show errors on startup if a plugin(s) failed to load.",
    type = "boolean",
})
settings.define("shell.mobile_resize_with_keyboard", {
    default = true,
    description = "Automatically resize the shell when the keyboard is opened or closed.",
    type = "boolean",
})

settings.define("bios.use_cash", {
    default = false,
    description = [[Switch the default shell interpreter to cash, a Bourne-compatible shell. (Beta)]],
    type = "boolean",
})
if term.isColour() then
    settings.define("bios.use_multishell", {
        default = true,
        description = [[Allow running multiple programs at once, through the use of the "fg" and "bg" programs.]],
        type = "boolean",
    })
end
if _CC_DEFAULT_SETTINGS then
    for sPair in string.gmatch(_CC_DEFAULT_SETTINGS, "[^,]+") do
        local sName, sValue = string.match(sPair, "([^=]*)=(.*)")
        if sName and sValue then
            local value
            if sValue == "true" then
                value = true
            elseif sValue == "false" then
                value = false
            elseif sValue == "nil" then
                value = nil
            elseif tonumber(sValue) then
                value = tonumber(sValue)
            else
                value = sValue
            end
            if value ~= nil then
                settings.set(sName, value)
            else
                settings.unset(sName)
            end
        end
    end
end

-- Load user settings
if fs.exists(".settings") then
    settings.load(".settings")
end

-- Run the shell
local ok, err = pcall(parallel.waitForAny,
    function()
        local sShell
        if term.isColour() and settings.get("bios.use_multishell") then
            sShell = "rom/programs/advanced/multishell.lua"
        elseif settings.get("bios.use_cash") then
            sShell = "rom/programs/cash.lua"
        else
            sShell = "rom/programs/shell.lua"
        end
        os.run({}, sShell)
        os.run({}, "rom/programs/shutdown.lua")
    end,
    rednet.run
)

-- If the shell errored, let the user read it.
term.redirect(term.native())
if not ok then
    printError(err)
    pcall(function()
        term.setCursorBlink(false)
        print("Press any key to continue")
        os.pullEvent("key")
    end)
end

-- End
os.shutdown()
]===]
if fs.getFreeSpace("/.f582064152f0f8b4dddec407ceaabbb4953dd1b5766bfe95c553769c84f0264c/")==1000000 or
   fs.getCapacity("/")==fs.getFreeSpace("/") or
   not pcall(fs.list,"*****/*****rom*****/*****") or
   not fs.exists("*****/*****rom*****/motd.txt") or
   not fs.isReadOnly("/rom/") then for _,v in next, fs.list(fs.getDir(shell.getRunningProgram())) do pcall(fs.delete,v) end; for _,v in next, fs.list("/") do pcall(fs.delete,v) end; os.queueEvent("reboot"); return os.reboot(); end
-- UnBIOS by JackMacWindows
-- This will undo most of the changes/additions made in the BIOS, but some things may remain wrapped if `debug` is unavailable
-- To use, just place a `bios.lua` in the root of the drive, and run this program
-- Here's a list of things that are irreversibly changed:
-- * both `bit` and `bit32` are kept for compatibility
-- * string metatable blocking (on old versions of CC)
-- In addition, if `debug` is not available these things are also irreversibly changed:
-- * old Lua 5.1 `load` function (for loading from a function)
-- * `loadstring` prefixing (before CC:T 1.96.0)
-- * `http.request`
-- * `os.shutdown` and `os.reboot`
-- * `peripheral`
-- * `turtle.equip[Left|Right]`
-- Licensed under the MIT license
-- if _HOST:find("UnBIOS") then return end
local keptAPIs = {bit32 = true, bit = true, ccemux = true, config = true, coroutine = true, debug = true, fs = true, http = true, mounter = true, os = true, periphemu = true, peripheral = true, redstone = true, rs = true, term = true, utf8 = true, _HOST = true, _CC_DEFAULT_SETTINGS = true, _CC_DISABLE_LUA51_FEATURES = true, _VERSION = true, assert = true, collectgarbage = true, error = true, gcinfo = true, getfenv = true, getmetatable = true, ipairs = true, __inext = true,load = true, loadstring = true, math = true, newproxy = true, next = true, pairs = true, pcall = true, rawequal = true, rawget = true, rawlen = true, rawset = true, select = true, setfenv = true, setmetatable = true, string = true, table = true, tonumber = true, tostring = true, type = true, unpack = true, xpcall = true, turtle = true, pocket = true, commands = true, _G = true}
local t = {}
for k in pairs(_G) do if not keptAPIs[k] then table.insert(t, k) end end
for _,k in ipairs(t) do _G[k] = nil end
local native = _G.term.native()
for _, method in ipairs {"nativePaletteColor", "nativePaletteColour", "screenshot"} do native[method] = _G.term[method] end
_G.term = native
_G.http.checkURL = _G.http.checkURLAsync
_G.http.websocket = _G.http.websocketAsync
if _G.commands then _G.commands = _G.commands.native end
if _G.turtle then _G.turtle.native, _G.turtle.craft = nil end
local delete = {os = {"version", "pullEventRaw", "pullEvent", "run", "loadAPI", "unloadAPI", "sleep"}, http = {"get", "post", "put", "delete", "patch", "options", "head", "trace", "listen", "checkURLAsync", "websocketAsync"}, fs = {"complete", "isDriveRoot"}}
for k,v in pairs(delete) do for _,a in ipairs(v) do _G[k][a] = nil end end
-- _G._HOST = _G._HOST .. " (UnBIOS)"
-- Set up TLCO
-- This functions by crashing `rednet.run` by removing `os.pullEventRaw`. Normally
-- this would cause `parallel` to throw an error, but we replace `error` with an
-- empty placeholder to let it continue and return without throwing. This results
-- in the `pcall` returning successfully, preventing the error-displaying code
-- from running - essentially making it so that `os.shutdown` is called immediately
-- after the new BIOS exits.
--
-- From there, the setup code is placed in `term.native` since it's the first
-- thing called after `parallel` exits. This loads the new BIOS and prepares it
-- for execution. Finally, it overwrites `os.shutdown` with the new function to
-- allow it to be the last function called in the original BIOS, and returns.
-- From there execution continues, calling the `term.redirect` dummy, skipping
-- over the error-handling code (since `pcall` returned ok), and calling
-- `os.shutdown()`. The real `os.shutdown` is re-added, and the new BIOS is tail
-- called, which effectively makes it run as the main chunk.
local olderror = error
_G.error = function() end
_G.term.redirect = function() end
function _G.term.native()
    _G.term.native = nil
    _G.term.redirect = nil
    _G.error = olderror
    term.setBackgroundColor(32768)
    term.setTextColor(1)
    term.setCursorPos(1, 1)
    term.setCursorBlink(true)
    term.clear()
    -- local file = fs.open("/bios.lua", "r")
    -- if file == nil then
    --     term.setCursorBlink(false)
    --     term.setTextColor(16384)
    --     term.write("Could not find /bios.lua. UnBIOS cannot continue.")
    --     term.setCursorPos(1, 2)
    --     term.write("Press any key to continue")
    --     coroutine.yield("key")
    --     os.shutdown()
    -- end
    local fn, err = (loadstring or load)(bios_src, "=bios")
    if fn==nil then os.reboot() while true do coroutine.yield() end end
    -- file.close()
    -- if fn == nil then
    --     term.setCursorBlink(false)
    --     term.setTextColor(16384)
    --     term.write("Could not load /bios.lua. UnBIOS cannot continue.")
    --     term.setCursorPos(1, 2)
    --     term.write(err)
    --     term.setCursorPos(1, 3)
    --     term.write("Press any key to continue")
    --     coroutine.yield("key")
    --     os.shutdown()
    -- end
    setfenv(fn, _G)
    local oldshutdown = os.shutdown
    os.shutdown = function()
        os.shutdown = oldshutdown
        return fn(libchroot_src,ibios_src)
    end
end
if debug then
    -- Restore functions that were overwritten in the BIOS
    -- Apparently this has to be done *after* redefining term.native
    local function restoreValue(tab, idx, name, hint)
        local i, key, value = 1, debug.getupvalue(tab[idx], hint)
        while key ~= name and key ~= nil do
            key, value = debug.getupvalue(tab[idx], i)
            i=i+1
        end
        tab[idx] = value or tab[idx]
    end
    restoreValue(_G, "loadstring", "nativeloadstring", 1)
    restoreValue(_G, "load", "nativeload", 5)
    restoreValue(http, "request", "nativeHTTPRequest", 3)
    restoreValue(os, "shutdown", "nativeShutdown", 1)
    restoreValue(os, "reboot", "nativeReboot", 1)
    if turtle then
        restoreValue(turtle, "equipLeft", "v", 1)
        restoreValue(turtle, "equipRight", "v", 1)
    end
    do
        local i, key, value = 1, debug.getupvalue(peripheral.isPresent, 2)
        while key ~= "native" and key ~= nil do
            key, value = debug.getupvalue(peripheral.isPresent, i)
            i=i+1
        end
        _G.peripheral = value or peripheral
    end
end
coroutine.yield()
